}
}
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
# Dynamic
par(mfrow=c(2,2), mar = c(0.1, 0.1, 2, 0.1))
plot.dynamic.sign(dynamic_net, displaylabels = T)
### sergm ###
set.seed(1234)
model <- sergm(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
model
### tsergm ###
# Joint
set.seed(1234)
joint <- tsergm(dynamic_net ~ Cross(~ edges_pos + ese_pos(d = 2)) +
Change(~ edges_pos + ese_pos(d = 2)),
times = c(0:3))
joint
library(ergm.sign)
load_all('/Users/mschalberger/Downloads/ergm.multi-private-mutex')
library(ergm.sign)
# Create random list of adjacency matrices
# Static
set.seed(1234)
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
# Dynamic
set.seed(1234)
lis <- c()
n <- 4
for (i in c(1:n)) {
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
lis[[i]] <- mat
}
### signnet ###
# Static
static_net <- signnet(mat, directed = F, loops = F, matrix.type = "adjacency")
class(static_net)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
class(dynamic_net)
### summary ###
# Static
summary(static_net)
# Dynamic
summary(dynamic_net)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
library(ergm.sign)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
library(ergm.sign)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
# Dynamic
par(mfrow=c(2,2), mar = c(0.1, 0.1, 2, 0.1))
plot.dynamic.sign(dynamic_net, displaylabels = T)
### sergm ###
set.seed(1234)
model <- sergm(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
setwd("~/Documents/Master Thesis/ergm.sign/R")
library(devtools)
load_all('/Users/mschalberger/Downloads/ergm.multi-private-mutex')
### sergm ###
set.seed(1234)
model <- sergm(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
model
### tsergm ###
# Joint
set.seed(1234)
joint <- tsergm(dynamic_net ~ Cross(~ edges_pos + ese_pos(d = 2)) +
Change(~ edges_pos + ese_pos(d = 2)),
times = c(0:3))
joint
# Separable TERGM
set.seed(1234)
separable <- tsergm(dynamic_net ~ Form(~ edges_pos + ese_pos(d = 2)) +
Diss(~ edges_pos + ese_pos(d = 2)),
times = c(0:3))
separable
### count ###
count(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
count(dynamic_net ~  edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
count(dynamic_net[[1]] ~  edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
count(dynamic_net ~ Cross(~ edges_pos + ese_pos(d = 2)) +
Change(~ edges_pos + ese_pos(d = 2)))
### simulate ###
# static
sim <- sim_sergm(model, nsim = 10, seed = 123)
summary(sim)
# dynamic
sim_dynamic <- sim_tsergm(joint, nsim = 10, seed = 123)
summary(sim_dynamic)
# static
set.seed(1234)
gof_sergm(model, nsim = 10)
set.seed(1234)
mcmc.diagnostics(model)
# dynamic
set.seed(1234)
gof_tsergm(joint, nsim = 10)
set.seed(1234)
mcmc.diagnostics(joint, vars.per.page = 4)
# static
# check nr 1
test1 <- sim_sergm(network.initialize(50, directed = F) ~
edges_pos +
edges_neg +
gwesf_pos(decay=0.3, fix = T),
coef = c(-3.9,-3,1),
seed = 1234)
set.seed(1234)
sergm(test1 ~  edges_pos + edges_neg + gwesf_pos(decay=0.3, fix = T))
count(test1 ~  edges_pos + edges_neg + gwesf_pos(decay=0.3, fix = T))
# check nr 2
test2 <- sim_sergm(network.initialize(60, directed = F) ~
triangles_pos +
triangles_neg +
gwdse(decay = 0.2, fix = T),
coef = c(-2,-2.5,1),
seed = 1234)
set.seed(1234)
sergm(test2 ~  triangles_pos +
triangles_neg +
gwdse(decay = 0.2, fix = T))
count(test2 ~ triangles_pos +
triangles_neg +
gwdse(decay=0.2, fix = T))
setwd("/Users/mschalberger/Downloads/Replication-Code-All-that-Glitters-main/Applications/Conflict events in the Syrian civil war")
library(dplyr)
library(lubridate)
# Load the csv file into a data frame
event_data <- read.csv("Data/1997-01-01-2021-03-31-Afghanistan-Iraq-Nigeria-Syria.csv") #acled
add_cov_data <- read.csv("Data/ACLEDgroups_covariates_update.csv") #acled
acronyms <- read.csv("Data/ACLEDgroups_covariates.csv") #acled
add_cov_data$acronym  = acronyms$acronym
add_cov_data$sponsor <- apply(add_cov_data[, 5:12], 1, function(x) {
names(x)[which(x == 1)]
})
# turn binary NAs into 0s
add_cov_data[,5:12][is.na(add_cov_data[,5:12])] <- 0
#event_data$event_date
event_data$event_date <- dmy(event_data$event_date)
# Preprocess
filter_acled <- function(data, year_events, threshold_fatalities = 0, threshold_participation = 5,
exclude_undefined_militia= T,  exclude_rioters = T, exclude_rebels = T) {
patterns <- c("Military Forces of Syria", "Police Forces of Syria", "Wa Harredh al Moa'mineen", "Military Forces of Turkey", "Military Forces of Iran", "Military Forces of Jordan", "Popular Mobilization Forces", "Military Forces of Iraq ", "YPG", "Military Forces of Russia", "PYD: Kurdish Democratic Union Party", "Sham Legion")
new_names <- c("Military Forces of Syria", "Police Forces of Syria", "Wa Harredh al Moa'mineen", "Military Forces of Turkey", "Military Forces of Iran", "Military Forces of Jordan", "Military Forces of Iraq: Popular Mobilization Forces", "Military Forces of Iraq", "YPG", "Military Forces of Russia", "YPG", "Al Sham Corps")
list <- c()
for (y in year_events) {
acled_syria <- data %>%
dplyr::filter(country == "Syria",
year %in% y,
fatalities >= threshold_fatalities,
!event_type %in% c("Strategic developments"),
!(actor1 == actor2 | actor1 == assoc_actor_1 | actor2 == assoc_actor_2)) %>%
dplyr::mutate_at(vars(actor1, actor2, assoc_actor_1, assoc_actor_2),
~ifelse(. %in% patterns,
new_names[match(., patterns)],
.)) %>%
dplyr::arrange(event_date)
tbl_actor <- table(c(acled_syria$actor1,acled_syria$actor2,acled_syria$assoc_actor_1, acled_syria$assoc_actor_2))
# Cut all actors that were active in less than 5 events
actors <- names(tbl_actor)[tbl_actor>=threshold_participation]
actors <- actors[actors %in% add_cov_data[,1]]
actors <- actors[!(seq_along(actors) %in% grep("Unidentified", actors))]
if(exclude_undefined_militia){
actors <- actors[!(seq_along(actors) %in% grep("Militia", actors))]
}
if(exclude_rioters){
actors <- actors[!(seq_along(actors) %in% grep("Rioters", actors))]
}
if(exclude_rebels){
actors <- actors[!actors %in% c("Kurdish Ethnic Militia (Syria)", "Rioters (Syria)", "Islamist Militia (Syria)", "Islamist Rebels (Syria)","Opposition Rebels (Syria)")]
}
# And cut all empty actors (unknown actors)
actors <- actors[nchar(actors) > 0]
#Create empty adjacency matrix
adj_matrix <- matrix(0, nrow = length(actors), ncol = length(actors))
dimnames(adj_matrix) <- list(actors,  actors)
# Loop over the rows of the data frame
for (i in 1:nrow(acled_syria)) {
# Get the values for actor1, actor2, assoc_actor_1, and assoc_actor_2 for this row
a1 <- acled_syria$actor1[i]
a2 <- acled_syria$actor2[i]
aa1 <- acled_syria$assoc_actor_1[i]
aa2 <- acled_syria$assoc_actor_2[i]
# If actor1 and actor2 are in the same row, set the value in the adjacency matrix to -1
adj_matrix[which(actors == a1), which(actors == a2)] <- -1
adj_matrix[which(actors == a2), which(actors == a1)] <- -1
# If actor1 and assoc_actor_1 are in the same row, set the value in the adjacency matrix to 1
adj_matrix[which(actors == a1), which(actors == aa1)] <- 1
adj_matrix[which(actors == aa1), which(actors == a1)] <- 1
# If actor2 and assoc_actor_2 are in the same row, set the value in the adjacency matrix to 1
adj_matrix[which(actors == a2), which(actors == aa2)] <- 1
adj_matrix[which(actors == aa2), which(actors == a2)] <- 1
}
list[[y]] <- adj_matrix
}
if (length(list) == 1) {
return(list[[year_events]])
} else {
return(list)
}
}
# Create adjacency matrix
adj_17_19 <- filter_acled(event_data, year_events = c("2017","2018", "2019"), threshold_participation = 3)
names <- lapply(adj_17_19, function (x) {x <- colnames(x)})
common_names <- intersect(intersect(names[[1]], names[[2]]), names[[3]])
adj_17_19 <- lapply(adj_17_19, function(adj) adj[which(row.names(adj) %in% common_names), which(colnames(adj) %in% common_names)])
adj_19 <- filter_acled(event_data, year_events = "2019", threshold_participation = 7)
# Create a signed network
net_19 <- signnet(adj_19, matrix.type = "adjacency", cov = add_cov_data)
net_17_19 <- signnet(adj_17_19, matrix.type = "adjacency", cov = add_cov_data)
# Network Descriptive
summary(net_19)
summary(net_17_19)
par(mar = c(0.1, 0.1, 0.1, 0.1))
set.seed(1234)
plot.static.sign(net_19, displaylabels = F, vertex.col = "type", vertex.legend = T, vertex.legend.pos = "topright", legend.size = 1)
set.seed(1234)
plot(net_17_19, displaylabels = F, vertex.col = "type", vertex.legend = T, vertex.legend.pos = "topleft", main = NULL, vertex.legend.size = 1.5)
set.seed(1234)
plot.dynamic.sign(net_17_19, displaylabels = F, vertex.col = "type", vertex.legend = T, vertex.legend.pos = "topleft", main = NULL, vertex.legend.size = 1.5)
mat <- matrix(NA, 8, 8)
diag(mat) <- "common"
set.seed(123)
model_19 <- sergm(net_19 ~ edges_pos + edges_neg +
gwesf_pos(0.25, fixed = T) + gwesf_neg(0.25, fixed = T) +
gwese_pos(0.25, fixed = T) + gwese_neg(0.25, fixed = T) +
nodemix_pos("sponsor", levels2 = mat) + nodemix_neg("sponsor", levels2 = mat) +
nodematch_pos("ethn_relig", diff = F) + nodematch_neg("ethn_relig", diff = F) +
nodematch_pos("type", diff = F) + nodematch_neg("type", diff = F))
base::summary(model_19)
coef_19 <- coef(model_19)
se_19 <- vcov(model_19)
conf_level <- 0.95
z <- qnorm((1 + conf_level) / 2)
lower <- coef_19 - z * sqrt(diag(se_19))
upper <- coef_19 + z * sqrt(diag(se_19))
df_19 <- data.frame(Estimate = round(coef_19, 3),
CI = paste("[",round(lower,3),",",round(upper, 3), "]", sep = ""))
set.seed(123)
model_1719 <- tsergm(net_17_19 ~
Cross(~ edges_pos + edges_neg +
gwesf_pos(0.25, fixed = T) + gwesf_neg(0.25, fixed = T) +
gwese_pos(0.25, fixed = T) + gwese_neg(0.25, fixed = T) +
nodemix_pos("sponsor", levels2 = mat) + nodemix_neg("sponsor", levels2 = mat) +
nodematch_pos("ethn_relig", diff = F) + nodematch_neg("ethn_relig", diff = F) +
nodematch_pos("type", diff = F) + nodematch_neg("type", diff = F))
+Change(~ edges_pos + edges_neg))
base::summary(model_1719)
coef_1719 <- coef(model_1719)
se_1719 <- vcov(model_1719)
lower <- coef_1719 - z * sqrt(diag(se_1719))
upper <- coef_1719 + z * sqrt(diag(se_1719))
df_1719 <- data.frame(Estimate = round(coef_1719, 3),
CI = paste("[",round(lower,3),",",round(upper, 3), "]", sep = ""))
par(mfrow=c(3,2))
set.seed(123)
gof_sergm(model_19, nsim = 1000)
set.seed(123)
mcmc.diagnostics(model_19)
set.seed(123)
par(mar = c(0.1, 0.1, 0.1, 0.1))
sim_19 <- sim_sergm(model_19, cov = add_cov_data)
set.seed(123)
plot(sim_19, displaylabels = F,vertex.col = "type")
build_manual()
build_manual()
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
find.package(ergm.multi)
library(devtools)
load_all('/Users/mschalberger/Downloads/ergm.multi-private-mutex')
find.package(ergm.multi)
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
### signnet ###
# Static
static_net <- signnet(mat, directed = F, loops = F, matrix.type = "adjacency")
class(static_net)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
# Create random list of adjacency matrices
# Static
set.seed(1234)
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
# Dynamic
set.seed(1234)
lis <- c()
n <- 4
for (i in c(1:n)) {
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
lis[[i]] <- mat
}
### signnet ###
# Static
static_net <- signnet(mat, directed = F, loops = F, matrix.type = "adjacency")
class(static_net)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
class(dynamic_net)
### summary ###
# Static
summary(static_net)
# Dynamic
summary(dynamic_net)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
### summary ###
# Static
summary(static_net)
library(ergm.sign)
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
# Create random list of adjacency matrices
# Static
set.seed(1234)
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
# Dynamic
set.seed(1234)
lis <- c()
n <- 4
for (i in c(1:n)) {
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
lis[[i]] <- mat
}
### signnet ###
# Static
static_net <- signnet(mat, directed = F, loops = F, matrix.type = "adjacency")
class(static_net)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
class(dynamic_net)
### summary ###
# Static
summary(static_net)
# Dynamic
summary(dynamic_net)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
# Dynamic
par(mfrow=c(2,2), mar = c(0.1, 0.1, 2, 0.1))
plot.dynamic.sign(dynamic_net, displaylabels = T)
### sergm ###
set.seed(1234)
model <- sergm(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
model
### tsergm ###
# Joint
set.seed(1234)
joint <- tsergm(dynamic_net ~ Cross(~ edges_pos + ese_pos(d = 2)) +
Change(~ edges_pos + ese_pos(d = 2)),
times = c(0:3))
joint
# Separable TERGM
set.seed(1234)
separable <- tsergm(dynamic_net ~ Form(~ edges_pos + ese_pos(d = 2)) +
Diss(~ edges_pos + ese_pos(d = 2)),
times = c(0:3))
separable
### count ###
count(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
count(dynamic_net ~  edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
count(dynamic_net[[1]] ~  edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
count(dynamic_net ~ Cross(~ edges_pos + ese_pos(d = 2)) +
Change(~ edges_pos + ese_pos(d = 2)))
### simulate ###
# static
sim <- sim_sergm(model, nsim = 10, seed = 123)
summary(sim)
# dynamic
sim_dynamic <- sim_tsergm(joint, nsim = 10, seed = 123)
summary(sim_dynamic)
# static
set.seed(1234)
gof_sergm(model, nsim = 10)
set.seed(1234)
mcmc.diagnostics(model)
# dynamic
set.seed(1234)
gof_tsergm(joint, nsim = 10)
set.seed(1234)
mcmc.diagnostics(joint, vars.per.page = 4)
# static
# check nr 1
test1 <- sim_sergm(network.initialize(50, directed = F) ~
edges_pos +
edges_neg +
gwesf_pos(decay=0.3, fix = T),
coef = c(-3.9,-3,1),
seed = 1234)
library(ergm.sign)
library(ergm.sign)
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
build_manual()
setwd("~/Documents/Master Thesis/ergm.sign/R")
build_manual()
devtools::load_all("~/Documents/Master Thesis/ergm.sign")
library(ergm.sign)
library(ergm.sign)
# Create random list of adjacency matrices
# Static
set.seed(1234)
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
# Dynamic
set.seed(1234)
lis <- c()
n <- 4
for (i in c(1:n)) {
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
lis[[i]] <- mat
}
### signnet ###
# Static
static_net <- signnet(mat, directed = F, loops = F, matrix.type = "adjacency")
class(static_net)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
class(dynamic_net)
### summary ###
# Static
summary(static_net)
# Dynamic
summary(dynamic_net)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
devtools::load_all(".")
# Create random list of adjacency matrices
# Static
set.seed(1234)
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
# Dynamic
set.seed(1234)
lis <- c()
n <- 4
for (i in c(1:n)) {
mat <- matrix(sample(c(-1,0,1),100,replace=TRUE),ncol=10)
mat[lower.tri(mat)] <- 0
diag(mat) <- 0
lis[[i]] <- mat
}
### signnet ###
# Static
static_net <- signnet(mat, directed = F, loops = F, matrix.type = "adjacency")
class(static_net)
# Dynamic
dynamic_net <- signnet(lis, directed = F, loops = F, matrix.type = "adjacency")
class(dynamic_net)
### summary ###
# Static
summary(static_net)
# Dynamic
summary(dynamic_net)
### summary ###
# Static
plot.static.sign(static_net, displaylabels = T, displayisolates = F)
# Dynamic
par(mfrow=c(2,2), mar = c(0.1, 0.1, 2, 0.1))
plot.dynamic.sign(dynamic_net, displaylabels = T)
### sergm ###
set.seed(1234)
model <- sergm(static_net ~ edges_pos + edges_neg + gwesf_pos(decay=0.5, fix = T))
setwd("./data")
library(dplyr)
library(lubridate)
# Load the csv file into a data frame
event_data <- read.csv("Data/1997-01-01-2021-03-31-Afghanistan-Iraq-Nigeria-Syria.csv") #acled
acronyms <- read.csv("Data/ACLEDgroups_covariates.csv") #acled
setwd("./ergm.sign_replication")
setwd("./ergm.sign_replication")
library(dplyr)
library(lubridate)
# Load the csv file into a data frame
event_data <- read.csv("Data/1997-01-01-2021-03-31-Afghanistan-Iraq-Nigeria-Syria.csv") #acled
getwd()
setwd("~/Documents/Master Thesis/ergm.sign")
build_manual()
library(ergm.sign)
build_manual()
build_manual()
